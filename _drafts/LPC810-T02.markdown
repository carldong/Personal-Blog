---
layout: tutorial
title: "LPC810 Cortex-M0+ Programming from Scratch - Part 2: .data and .bss"
categories: tutorials
date: 0000-01-01
tags: [tutorial, Cortex-M0+, ARM, linker]
---

{% assign code_root = "repo/02-BSS_Data" %}

In this tutorial, we are going to finish the vector table and the initialization of `.data` and `.bss` section. The tutorial will continue based on Tutorial 1 (I apologize that the archive and the folder is named `00-Getting_Started`, which should be `01`, but I don't want to change it).

# Basics about .rodata, .data and .bss
**Disclaimer again: I am not expert on this topic, so I can be wrong.**

`.rodata` contains the constant variables in C. Such as:

	const unsigned int variable = 1;

`.data` section contains initialized variables in C. Such as:

	unsigned int variable = 1;

`.bss` section contains uninitialized variables. Such as:

	unsigned int variable;

Typically, the data in `.bss` section is initialized as zero.

# Linker Script
I will attach the entire linker script at the end of this section. Now I will just go over the details.

## .rodata Section
First, since `.rodata` is just constants, it doesn't need to be copied to RAM. After all, our small device only contains 1KB of RAM. Therefore, we change the `.text` section definition like this:

    .text : {
        KEEP(* (.isr_vectors));
        . = ALIGN(4);
        __vec_end__ = .;
        /*. = 0xC4;*/ /* End of vectors */
        * (.text);
		* (.text*);
        . = ALIGN(4);
		* (.rodata);
		* (.rodata*);
		. = ALIGN(4);
        __end_text__ = .;
    } > FLASH

The above code will tell the linker to put `.rodata` directly after `.text` of each object file, and into the `.text` section of the generated executable. Note the `(.text*)` is here because sometimes there are some `.text.something` generated by the compiler.

## .data Section
This section is somewhat different from the previous ones. Apparently, at execution, all data is in RAM, but since they contain initialized values, they have to be stored into flash. Therefore, the `.data` section has two addresses: **load address** and **run-time address**. The labels in `.data` section should be in run-time address in order for the program to access and change the value. Now we will look into the details of the definition of this section.

	.text : {
		...
	} > FLASH

	__flash_sdata__ = .;

	.data : AT(__flash_sdata__) {
		...
	} > RAM

Here, the `__flash_sdata__` symbol is the address right after the `.text` section, and is where `.data` section is stored. In other words, `__flash_sdata__` is the beginning of the *load address* of the `.data` section. Since the labels are using *run-time address*, there is the `> RAM`.

    .data : AT(__flash_sdata__){
    	__data_start__ = .;
        * (.data);
        * (.data*);
        . = ALIGN(4);
	__data_end__ = .;
    } > RAM
    __data_size__ = __data_end__ - __data_start__;

The inside is the same syntax, so I will not explain here. The labels will be used by startup code later.

## .bss Section
The `.bss` section has no initial value, so it only has a *run-time address*.

    .bss : {
        __bss_start__ = .;
    	* (.bss);
    	* (.bss*);
        . = ALIGN(4);
        __bss_end__ = .;
    } > RAM
    __bss_size__ = __bss_end__ - __bss_start__;

The syntax is the same, so I won't explain.

## The entire Linker Script
Note: Since the above code snippet are copied and pasted into the post, while the following one is included directly, I may forget to update the above snippets. Please use this one as the correct reference.

{% highlight C %}
{% include {{ code_root }}/LPC810/lpc810.ld %}
{% endhighlight %}

# Vector Table and Startup Code

## The startup file
This section only gives the startup file `crt0.S`. It will be explained later

{% highlight gas %}
{% include {{ code_root }}/crt0.S %}
{% endhighlight %}


## Vector Table
This part is just work: Copy everything from the *CM0 Guide*(Cortex-M0+ Devices Generic User Guide) and *81x Manual*(LPC81x User Manual). It is just that long list of `.long` expressions. Note that currently none of the added labels are defined yet, so we are going to define them. Since we all like C instead of assembly(at least, for me), we are going to define them in a C file. Here comes `vector.c`:

{% highlight C %}
{% include {{ code_root }}/vectors.c %}
{% endhighlight %}

Before compiling, don't forget to add this file to `CSRC`.

The function prototypes all have the `extern` keyword, since the handler can be declared outside the `vector.c`. However, to make development easier, we don't want to declare all those handlers before starting to blink an LED, so we first make a naked function `_unhandled_exception()` which just does an infinite loop, so that when the processor receives an unhandled exception, it will 'stop', although it is running.

	__attribute__((naked))

This basically means the C compiler is not saving context of this function, so current registers are not pushed in stack.

	void NMI_Handler(void) __attribute__((weak, alias("_unhandled_exception")));
	...

Here, the attribute `weak` means that we can override this declaration somewhere else. `alias` means that it is just another name of `_unhandled_exception()`. Now, whenever there is an exception occuring but we have not defined a handler, the `_unhandled_exception()` will be called.

