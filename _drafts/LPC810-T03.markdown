---
layout: tutorial
title: "LPC810 Cortex-M0+ Programming from Scratch - Part 3: Migrate to CMake and Start Writing Library"
categories: tutorials
date: 0000-01-01
tags: [tutorial, Cortex-M0+, ARM, linker]
---

{% assign code_root = "repo/03-GPIO" %}

[Part 2]({{ site.baseurl }}{% post_url 2014-11-27-LPC810-T02 %})

In this tutorial, we are going to do the following things

- Migrate to [CMake](http://cmake.org)
- Start writing library for GPIO

If you just want the source, download here: [03-GPIO.tar.xz]({{ site.baseurl }}/archives/03-GPIO.tar.xz)

# Migrate to CMake
This is not a tutorial on CMake, so I will not explain the syntax. The comments should be enough. First, change the directory structure like this(generated by `tree -n`):

	.
	├── CMakeLists.txt
	├── lpc810
	│   ├── crt0.S
	│   ├── device.h
	│   ├── lpc810.ld
	│   └── vectors.c
	├── main.c
	└── Toolchain-arm-none-eabi.cmake

	1 directory, 7 files

I would recommend you to keep the `Makefile` for now to compare. If `cmake` doesn't generate the exact same output(can be inspected from the output of `size`), something is wrong. Basically, just rename `LPC810` to `lpc810`, move `crt0.S` and `vectors.c` into `lpc810`. Now let's look at the CMake files.

CMakeLists.txt:

{% highlight cmake %}
{% include {{ code_root }}/CMakeLists.txt %}
{% endhighlight %}

Toolchain-arm-none-eabi.cmake:

{% highlight cmake %}
{% include {{ code_root }}/Toolchain-arm-none-eabi.cmake %}
{% endhighlight %}

To use CMake on this project, first make sure the toolchain install root is added into the toolchain file (`Toolchain-arm-none-eabi.cmake`). Not the `<somewhere>/bin` directory, but the `<somewhere>` path. Then, make a folder for building the source. I made a `build/` directory under the source directory in this example. Then, under the `build/` directory, run the following command:

	cmake ..

If everything goes right, when you run `make`, the code should compile without error. Compare the output of `arm-none-eabi-size` with the one generated by `Makefile`. In this tutorial, I have:

    text	   data	    bss	    dec	    hex	filename
     392	      4	      4	    400	    190	main.elf	

This is almost definitely different from yours, because this is the size of the executable after I *finished* this tutorial.

# GPIO Library
For now and some future tutorials, we are going to work on the new file `device.h`. It is located under `lpc810/device.h`. Why we are working on this? Obviously no one would like to look up the datasheet and calculate the memory address each time working with peripherals. Therefore, we are making a header to ease the job.

Note: I assume the reader at least knows basics of C, otherwise this part is almost impossible to understand. However, if you just want the library, you can safely copy the code only. Just remember this library is a work in progress. I will post the entire `device.h` at the end.

## Some typedefs
These `typedef`s are recommended by the *CMSIS* standard. I don't know that standard a lot and I don't intend to implement the entire *CMSIS*, I just come over it and think that it is a good idea to include them:

	#define __I volatile const
	#define __O volatile
	#define __IO volatile

Now, *read only* registers are marked `__I`, *write only* registers are marked `__O`, *read and write* registers are marked `__IO`.

## Switch Matrix
Since the first register we used in the blink example is in the *switch matrix*, we are going to implement it first. Please prepare *81x Manual* (*LPC81x User Manual*) and open to the chapter *Switch Matrix*. At the section *Register description*, there is a table about all registers available in the switch matrix. The important part here are the *Offset* values and the *base address*. First, make a struct like this:

	typedef struct {
	} SWM_TypeDef;

This defines a type of `struct`, `SWM_Typedef`. At this point it is still unclear how it will be used, but it will become clear as we progress.

Reading the table, we see there are `PINASSIGN0` through `PINASSIGN8`, each takes a word, or 32 bits. Therefore, we add the definitions like this:

	typedef struct {
	  __IO uint32_t PINASSIGN0;
	  __IO uint32_t PINASSIGN1;
	  __IO uint32_t PINASSIGN2;
	  __IO uint32_t PINASSIGN3;
	  __IO uint32_t PINASSIGN4;
	  __IO uint32_t PINASSIGN5;
	  __IO uint32_t PINASSIGN6;
	  __IO uint32_t PINASSIGN7;
	  __IO uint32_t PINASSIGN8;
	} SWM_TypeDef;

In C, the start address of one element follows right after the end address of the previous element. Therefore, `PINASSIGN0` has offset `0x000` and `PINASSIGN1` has offset `0x004`, etc. Clearly, this pattern matches the table up to PINASSIGN8. The next element, `PINENABLE0`, has offset `0x1C0`, so we need some spacing after `PINASSIGN8`. Doing some simple math:

$$\rm
	0x1C0 - 0x024 = 0x19C
$$

We add an array of bytes for the spacing (I will not include the `struct {}`. If unclear, please read the complete file, or send me an email).

	uint8_t RESERVE9[0x19C]

Remember, the actual address does not correspond to any *physical memory*, so this won't take 412 bytes of memory. After this line, we define the `PINENABLE0`:

	__IO uint32_t PINENABLE0;

Now, this register has offset `0x1C0`. We have defined the struct for *switch matrix* now, so we have all the offsets. To add the base address, we need this `#define` statement outside:

    #define SWM ((SWM_TypeDef *) ((uint32_t) 0x4000C000))

This line may be confusing for those not very familiar with C. It means take the number `0x4000C000` and cast it into a `SWM_Typedef` pointer. Therefore, if we are accessing `SWM->PINENABLE0`, we are actually accessing memory address `0x4000C1C0`.

Now it's time to integrate this into our main code. In the `main.c`, change this line:

	*(vp) 0x4000C1C0 = 0xFFFFFFBFUL;

to

	SWM->PINENABLE0 = 0xFFFFFFBFUL;

Both line does the exact same thing, but the second line is much clearer. Note that the generated assembly code is a bit different. The former uses a direct accesss without offset, the latter uses an offset:

	/* PIO0_2 is used by SWD, so disable it */
	SWM->PINENABLE0 = 0xFFFFFFBFUL;
	c8:   4a16            ldr     r2, [pc, #88]   ; (124 <main+0x60>)
	ca:   23e0            movs    r3, #224        ; 0xe0 <- 2 more bytes
	cc:   005b            lsls    r3, r3, #1             <- 2 more bytes
	ce:   2141            movs    r1, #65 ; 0x41
	d0:   4249            negs    r1, r1
	d2:   50d1            str     r1, [r2, r3]

Notice the `str` instruction, in the `[r2, r3]`, `r2` contains `0x4000C000`, and `r3` contains `0x1C0`. Therefore, this method takes 4 bytes more space than direct address access.

## IOCON
We don't need to use this yet, but we are still including it. Note: since I haven't used it, so I cannot guarantee that this part is correct, so I will not explain it here. Please read the complete source

## GPIO Registers
This is quite a long definition because the GPIO register includes a lot of information.
