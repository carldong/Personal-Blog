---
layout: tutorial
title: "LPC810 Cortex-M0+ Programming from Scratch - Part 2: .data and .bss"
categories: tutorials
date: "2014-11-27 21:04:40"
tags: [tutorial, Cortex-M0+, ARM, linker]
---

{% assign code_root = "repo/02-BSS_Data" %}
[Part 1]({{ site.baseurl }}{% post_url 2014-11-27-LPC810-T01 %})

In this tutorial, we are going to finish the vector table and the initialization of `.data` and `.bss` section. The tutorial will continue based on Tutorial 1. If you want the entire working code, [02-BSS_Data.tar.xz]({{ site.baseurl }}/archives/02-BSS_Data.tar.xz).

# Basics about .rodata, .data and .bss
**Disclaimer again: I am not expert on this topic, so I can be wrong.**

`.rodata` contains the constant variables in C. Such as:

    const unsigned int variable = 1;

`.data` section contains initialized variables in C. Such as:

    unsigned int variable = 1;

`.bss` section contains uninitialized variables. Such as:

    unsigned int variable;

Typically, the data in `.bss` section is initialized as zero.

# Linker Script
I will attach the entire linker script at the end of this section. Now I will just go over the details.

## .rodata Section
First, since `.rodata` is just constants, it doesn't need to be copied to RAM. After all, our small device only contains 1KB of RAM. Therefore, we change the `.text` section definition like this:


    .text : {
        KEEP(* (.isr_vectors));
        . = ALIGN(4);
        __vec_end__ = .;
        /*. = 0xC4;*/ /* End of vectors */
        * (.text);
        * (.text*);
        . = ALIGN(4);
        * (.rodata);
        * (.rodata*);
        . = ALIGN(4);
        __end_text__ = .;
    } > FLASH


The above code will tell the linker to put `.rodata` directly after `.text` of each object file, and into the `.text` section of the generated executable. Note the `(.text*)` is here because sometimes there are some `.text.something` generated by the compiler.

## .data Section
This section is somewhat different from the previous ones. Apparently, at execution, all data is in RAM, but since they contain initialized values, they have to be stored into flash. Therefore, the `.data` section has two addresses: **load address** and **run-time address**. The labels in `.data` section should be in run-time address in order for the program to access and change the value. Now we will look into the details of the definition of this section.

    .text : {
        ...
    } > FLASH

    __flash_sdata__ = .;

    .data : AT(__flash_sdata__) {
        ...
    } > RAM

Here, the `__flash_sdata__` symbol is the address right after the `.text` section, and is where `.data` section is stored. In other words, `__flash_sdata__` is the beginning of the *load address* of the `.data` section. Since the labels are using *run-time address*, there is the `> RAM`.

    .data : AT(__flash_sdata__){
        __data_start__ = .;
        * (.data);
        * (.data*);
        . = ALIGN(4);
        __data_end__ = .;
    } > RAM
    __data_size__ = __data_end__ - __data_start__;

The `__data_start__` and `__data_end__` are the start and end of *run-time address*. The others are have familiar syntax, so I will not explain here. The labels will be used by startup code later.

## .bss Section
The `.bss` section has no initial value, so it only has a *run-time address*.

    .bss : {
        __bss_start__ = .;
        * (.bss);
        * (.bss*);
        . = ALIGN(4);
        __bss_end__ = .;
    } > RAM
    __bss_size__ = __bss_end__ - __bss_start__;

The syntax is the same, so I won't explain.

## The entire Linker Script
Note: Since the above code snippet are copied and pasted into the post, while the following one is included directly, I may forget to update the above snippets. Please use this one as the correct reference.

{% highlight C %}
{% include {{ code_root }}/LPC810/lpc810.ld %}
{% endhighlight %}

# Vector Table and Startup Code

## The startup file
This section only gives the startup file `crt0.S`. Details will be explained later

{% highlight gas %}
{% include {{ code_root }}/crt0.S %}
{% endhighlight %}


## Vector Table
This part is just work: Copy everything from the *CM0+ Guide*(Cortex-M0+ Devices Generic User Guide) and *81x Manual*(LPC81x User Manual). It is just that long list of `.long` expressions (really, *long* expressions). Note that currently none of the added labels are defined yet, so we are going to define them. Since we all like C instead of assembly(at least, for me), we are going to define them in a C file. Here comes `vector.c`:

{% highlight C %}
{% include {{ code_root }}/vectors.c %}
{% endhighlight %}

Before compiling, don't forget to add this file to `CSRC` in the `Makefile`.

The function prototypes all have the `extern` keyword, since the handler can be declared outside the `vector.c`. However, to make development easier, we don't want to declare all those handlers before starting to blink an LED, so we first make a naked function `_unhandled_exception()` which just does an infinite loop, so that when the processor receives an unhandled exception, it will 'stop', although it is running.

    __attribute__((naked))

This basically means the C compiler is not saving context of this function, so current registers are not pushed in stack.

    void NMI_Handler(void) __attribute__((weak, alias("_unhandled_exception")));
    ...

Here, the attribute `weak` means that we can override this declaration somewhere else. `alias` means that it is just another name of `_unhandled_exception()`. Now, whenever there is an exception occuring but we have not defined a handler, the `_unhandled_exception()` will be called.


## Initialization
Now we are finally explaining how `.data` and `.bss` are initialized. Before looking at the code, please have the *CM0+ Guide* or *81x Manual* open to the section where instructions are described.

        .thumb_func
        .global Reset_Handler
    Reset_Handler:
        cpsid i
        ldr r0, =__flash_sdata__
        ldr r1, =__data_start__
        ldr r2, =__data_size__

As explained in previous part, `.thumb_func` is required for the assembler to correctly generate code. `.global Reset_Handler` means that the *symbol* `Reset_Handler` is accessible externally. I will go over syntax of each line containing new instructions or directives here.

    label:

This is a label containing the address of the *next* instruction.

    cpsid i

This instruction disables all maskable interrupts

    ldr Rt, label

This instruction loads the value from address *label* into register *Rt*. Here, for example, we have label `__flash_sdata__`. Here I don't understand the detailed reasoning of the syntax, but to load the address of a label you will need `=label_name`. In this case,

    ldr r0, =__flash_sdata__

The next unfamiliar instruction is

    cmp Rn, #imm

This compares an *immediate number* with value stored in *Rn*. An *immediate number* is a constant that is a part of the instruction. Here, the `imm` must be in range 0-255. The reasoning why `imm` cannot be 32 bit is quite simple: one instruction is 16 or 32 bit wide, so the `imm` cannot take 32 bits.

Here, we have

    cmp r2, #0

If the value in *R2* equals to 0, the condition flag *Z* in register *Application Program Status Retister*(APSR) is set(read *CM0+ Guide* for detailed description).

Next instruction is

    b{cond} label

The `{cond}` here is suffix to the condition to test. If the condition is true, the program will *branch* to the label, i.e. the next instruction executed is the one right after the label. In our case, we are testing for equal, i.e. flag *Z* set. Therefore, the instruction used is:

    beq init_bss

Therefore, if `__data_size__` is zero, the label `copy` will be skipped. Otherwise, it is executed.

The next instruction:

    ldr<h|b> Rt, [Rn{, #imm}]

Here, the `<h|b>` means it can be `ldrh` or `ldrb`. `ldrh` loads a halfword(2 bytes), while `ldrb` loads one byte. If written in syntax like C it is something like

    Rt = *(Rn+imm)

That means, load a value to register *Rt* from the address stored in *Rn* plus `#imm` (i.e the offset).

Here, we are loading the value from address stored in `R0` into register `R4`

    ldrb r4, [r0]

The store instruction is

    str<h|b> Rt, [Rn{, #imm}]

It is basically the same as the load instruction. If written in C-like syntax it is

    *(Rn+imm) = Rt

That is, store the value of `R4` into the address in *Rn* with offset `#imm`.

    add{s} {Rd, } Rn, <Rn|#imm>

Here there are too many combinations, so please read the *CM0+ Guide* for detail. Just note that only `adds` can use immediate numbers, `add` can only take registers (at least for my device). Since we are copying data, we need to advance the 'pointers' after each copy, we have code like this:

    adds r0, #1

In order to copy the correct number of data, we decrement `R2`, which stores the remaining bytes to copy, and loop over `copy`. So we have:

    subs r2, #1
    bne copy

The above means, after the `subs` instruction, if `R2` is not zero, the flag *Z* is cleared, and the condition *NE* will be true, and `bne copy` will branch to copy label.

The next section is the same, and the only unfamiliar instruction is

    movs Rd, #imm

Which means load an *immediate number* into register `Rd`. Here, the register `R4` is used to store value `0` for clearing the bss addresses.

After the `copy` and `zero` section, it is finally time to branch to main!

    cpsie i

The above instruction enables interrupts.

    b main

Here, since no `{cond}` is specified, the program will unconditionally branch to `main` label. In this case, it is just the `main()`.

Finally, we need to align the code to 4 bytes becaue we use the Thumb instructions, which mixes some 32 bit instructions and some 16 bit instructions. I tried without the `.align` directive, and while I read the disassembly code and it seems that some part is incorrect. I am not completely sure about this, because the behavior didn't look wrong. However, I will still include this just in case. The worst thing of this directive is to waste 2 bytes of flash, anyway.

## The Main Code
Now let's setup the main code to test that everything works right.

{% highlight C %}
{% include {{ code_root }}/main.c %}
{% endhighlight %}

This file does the same thing as the one in the previous part. However, it tests all sections and startup code:

    unsigned long wait;

This line tests the `.bss` section.

    unsigned long until = 0xDEADBEEF;

This line tests the `.data` section.

    const unsigned long begin = 0xDEAFBEEF;

This line tests the `.rodata` section.

If the LED blinks, everything works.

Up to the date of writing (2014-11-27), this is the farthest I can go. In other words, that is all I know. I am now working on a library that defines useful macros and structs, and that will come next.
